# 后台开发笔记


## 说明

这是关于 后台开发-核心技术与应用实践 的读书笔记, 笔记内存分布和书中章节的安排一致

## C++编程常用技术

### 函数模板

函数模板,实际上建立一个通用函数. 函数类型和形参不具体制定, 而用``一个虚拟的类型``代表. 这个通用函数就是函数模板

定义函数模板的一般格式:

```C++
template<typename T>
```

举例:

```C++
#include<iostream>
using namespace std; template<typename T>
T min(T a,T b,T c){    
    if(a>b) a=b; 
    if(a>c) a=c;

    return a;
}
int main() {
    int a=l , b=2,c=3;
    cout<<min(a,b,c)<<endl;
    long long al=l000000000,bl=2000000000,cl=3000000000;
    cout<<min(al, bl, cl )<<endl;

    return O;
}
```

### do{}while(0) 的用处

```C++
#define fun1(x) {\
    statement1;\
    statement2;\
}

#define fun2(x) {\
    do {\
        statement1;\
        statement2;\
    }while(0)\
}

int main(void) {
    if(cond == 0)
        fun1(param);    // right
    else if(cond == 1) 
        fun2(param);    // wrong
    else 
        statement;

    return 0;
}

```

通过以上代码, 我们可以得知 do{}while(0) 可以防止宏定义函数产生的问题

### 条件编译+extern "C"

```C++
#ifdef _cplusplus
    extern "C" {
        // 如果定义了_cplusplus 则要加extern "C" 使得代码以C语言的语法进行编译
    }
#endif
```

## 面向对象的C++

### 静态成员方法

两种写法:``Class fun();`` 和 ``obj.fun();``

### 空类所占的大小为1byte

### 模板类
```C++
template <class T>
class Test {
    private:
        T x, y;
    public:
        Test(T a, T b) : x(a), y(b) {}
}

int main(void) {
    Test <int> i(1, 2);
    return 0;
}
```

### 单例模式

通过一个静态指针来保存唯一的对象实例, 并返回实例地址. 注意: ``构造方法必须为private``

## 常用STL的使用

### vector
#### 遍历vector
```C++
vector<int> vec = sourceVec;
vector<int> ::iterator iter;
for(iter = vec; iter != vec.end(); iter++) {
    // do something   
}
```

#### 增删元素
```C++
/* 添加 */
vec.push_back(item);
vec.insert(iter);
/* 删除 */
vec.pop_back();
vec.erase(iter);// 注意返回值是被删元素下一个元素
```
#### 缩小空间
```C++
// vector<int>().swap<vec>;
// vec.swap(vector<int>());
void clearVector(vector<T>)
```

### map
#### 增删元素

```C++
/*添加*/
MAP.insert(pair<int, string>(0, "test"));// insert() 若存在, 会覆盖
MAP.insert(map<int,  string>::value_type (0, "test"));
MAP[0] = "test";// 若存在, 会覆盖

/*删除*/
map.erase(key);
map.earse(iter);
map.earse(iter, e);

```

#### 遍历map
总共有三种遍历方式
第一种:前向迭代器迭代
```C++
map<int, string>::iterator iter;
for(iter = MAP.begin(); iter != MAP.end(); iter++) {
    // do something
}
```
第二种:反向迭代器迭代

注: rbegin() 指向最后, 这种迭代方式是从后向前

```C++
map<int , string>::reverse_iterator riter;
for(riter = MAP.rbegin(); riter != MAP.rend(); riter++) {
    // do something
}
```

第三种:数组方式
```C++
for(int i = 0;  i < MAP.size(); i++) {
    MAP[i]; // do something
}
```

#### 查找

find定位数组出现位置, 返回一个迭代器, 数据出现, 返回所在位置的迭代器, 若无数据, 则返回end()

## 编译
MoYu.
摸鱼.
## 调试
MoYu.
摸鱼.
## TCP协议
### 网络模型
#### 七层网络模型
- 应用层 
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层

除了``数据链路层``之外, 其他每层都会给上层的数据加抱头(数据链路层还加报尾). 

#### 四层网络模型
使用最为广泛的TCP/IP分层模型

- 应用层    DNS/FTP/HTTP/SMTP...
- 传输层    TCP/IP
- 网间层    TCMP/IP
- 网络接口  ARP/RARP

##### 网络接口层
网络接口层包括用于协作IP数据在已有网络介质上传输的协议. 它提供了TCP/IP协议的数据结构和实际物理硬件之间的链接
##### 网间层
网间层对应OSI七层参考模型的网络层, 包含IP协议 RIP协议(路由信息协议), 负责数据的包装, 寻址和路由. 同时还包含ICMP(网间控制报文协议)用于提供网络诊断信息.
##### 传输层
传输层对应OSI七层参考模型的传输层, 它提供两种端对端的通信服务. ``TCP协议``提供可靠的数据流传输服务, ``UDP协议``提供不可靠的用户数据报服务.
##### 应用层
应用层对于OSI七层参考模型的应用层和表示层, 包含Finger Whois FTP HTTP等.

### TCP头部
![TCP头部](pic/1.png)